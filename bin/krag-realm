#!/usr/bin/env coffee

http = require 'http'
optimist = require 'optimist'
path = require 'path'
WebSocketServer = require('websocket').server

{Vec2} = require 'justmath'
{GameMaster} = require '../lib/game'
constants = require '../lib/constants'

argv = optimist
  .options('h', alias: 'host', default: '127.0.0.1')
  .options('p', alias: 'port')
  .argv

class RealmProtocolClient

  @_NextID: 1

  constructor: (@conn) ->
    @id = RealmProtocolClient._NextID++

  onMessage: (command, obj) ->
    console.log 'XXX', command, obj

  toString: ->
    return "<RealmClient #{ @id }>"

clients = {}
gm = new GameMaster()

update = ->
  gm.doRound()
  state = gm.getFullState()
  for id, client of clients
    client.conn.send JSON.stringify ['state', state]
  return

setInterval update, constants.GAME_SPEED

httpServer = http.createServer()
httpServer.listen argv.port, argv.host, ->
  console.log "Realm Server listening on #{ argv.host }:#{ argv.port }"
httpServer.on 'error', (err) ->
  console.error  "Realm Server error: #{ err }"
  process.exit 1

wsServer = new WebSocketServer(
  httpServer: httpServer
  autoAcceptConnections: false
)
wsServer.on 'request', (req) ->
  try
    conn = req.accept 'realm-protocol', req.origin
  catch e
    console.error "Protocol error:", e
    conn.close()
    return

  client = new RealmProtocolClient(conn)
  clients[client.id] = client
  console.log "#{ client.toString() } connected."

  conn.on 'message', (message) ->
    try
      tuple = JSON.parse message.utf8Data
    catch e
      console.error "#{ client.toString() } sent invalid message: #{ message.utf8Data }"
      return
    [command, obj] = tuple
    client.onMessage command, obj

  conn.on 'close', ->
    delete clients[client.id]
    console.log "#{ client.toString() } disconnected."
