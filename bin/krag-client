#!/usr/bin/env coffee

optimist = require 'optimist'
WebSocketClient = require('websocket').client

{Map} = require '../lib/map'
{ClientWorld} = require '../lib/game'
{Vec2} = require 'justmath'

argv = optimist
  .options('h', alias: 'host', default: '127.0.0.1')
  .options('p', alias: 'port', default: 8200)
  .options('b', alias: 'bgcolor', default: 'black')
  .options('f', alias: 'fgcolor', default: 'white')
  .options('v', alias: 'verbose').boolean('v')
  .argv

debug = (message...) ->
  if argv.verbose then console.error message...

class View

  @Colors: ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white']

  constructor: (@bgcolor, @fgcolor) ->
    @charm = require('charm')()
    @charm.pipe(process.stdout)
    @charm
      .reset()
      .erase('screen')
      .cursor(false)
      .position(0, 0)
    @charm.background(@bgcolor)
    @charm.foreground(@fgcolor)

  draw_map_cell: (cell) ->
    p = cell
    @charm.position p.x + 1, p.y + 1
    switch world.map.get(p)
      when Map.Cells.EMPTY
        @charm.write ' '
      when Map.Cells.WALL
        switch world.map.wallType p
          when 'h' then @charm.write '-'
          when 'v' then @charm.write '|'
          else @charm.write '+'
      when Map.Cells.ROOM
        @charm.write '.'
      when Map.Cells.DOOR
        @charm.write '_'
      when Map.Cells.HALLWAY
        @charm.write '#'

  draw_agent: (agent) ->
    @charm.position agent.location.x + 1, agent.location.y + 1

    # All dead agents are a corpse.
    if not agent.isAlive()
      @charm.write 'x'
      return

    switch agent.type
      when 'drone' then @charm.write 'o'
      when 'mosquito'
        # TODO I guess you're supposed to chain method calls (sigh)
        @charm.push true
        @charm.foreground('red').write 'M'
        @charm.pop true
      when 'drone' then @charm.write 'o'
      else @charm.write '?'

  draw: (world) ->
    # If we haven't seen the world before, draw the whole thing from
    # scratch and prime the @oldlocations pump (TODO world is a bit of a
    # misnomer; presently each world is actually a realm, ie a floor of
    # the dungeon).
    if not @oldlocations?
      debug "haven't drawn the world before!  exciting!"

      # save the locations
      @oldlocations = {}
      for a in world.agents
        @oldlocations[a.id] = new Object a.location
      debug "made a new oldlocations:\n", @oldlocations

      # erase & draw the entire screen (ie the whole map).
      @charm.erase 'screen'
      world.map.foreach (p) =>
        @draw_map_cell p

    # update the view to match the new world
    # the world contains:
    #   * array of agents & their positions (x, y)
    #   * 2D array of map tiles:
    #       [ [ 'HALLWAY', 'HALLWAY', 'HALLWAY', 'HALLWAY', 'HALLWAY', 'HALLWAY' ],
    #         [ 'EMPTY', 'EMPTY', 'EMPTY', 'WALL', 'WALL', 'WALL', 'WALL', 'WALL', 'HALLWAY' ] 
    #         (etc, etc)
    #       ]
    # it's a big waste to redraw the whole world every tick (even in
    # 2013, not everybody has a fast terminal).  Only redraw things that
    # have changed.  Assume that the screen looks like the last frame,
    # and that only agents change (TODO this is a false assumption in
    # the long run).
    # TODO surely there's a shorter coffee idiom for "get the first item
    # out of a list for which this expression is true?"
    nskeeter = a for a in world.agents when a.type is 'mosquito'
    oskeeterlocation = @oldlocations[nskeeter.id]

    debug '[old, new] =', [oskeeterlocation, nskeeter.location]

    # first, erase all the old positions by redrawing the appropriate map tiles
    for k, v of @oldlocations
      # TODO why isn't it a Vec2 to begin with?
      if v.id is nskeeter.id
        debug "about to overwrite this position: ", v.location
      @draw_map_cell new Vec2 v

    # second, draw all the new positions
    # Always draw alive agents on top of dead ones.
    world.agents.sort (a, b) -> if a.isAlive() then 1 else -1
    @draw_agent a for a in world.agents

    # Remember the world for when the next frame comes around
    for a in world.agents
      @oldlocations[a.id] = new Object a.location

  teardown: ->
    @charm.cursor(true).erase('line')

client = null
world = new ClientWorld()
view = new View argv.bgcolor, argv.fgcolor

process.on 'exit', ->
  view.teardown()

tryConnecting = ->

  client = new WebSocketClient()

  client.on 'connectFailed', (err) ->
    if err.code in ['ECONNREFUSED', 'ECONNRESET']
      setTimeout tryConnecting, 500
    else
      debug err

  client.on 'connect', (conn) ->
    console.log 'Connected to realm server'

    conn.on 'message', (message) ->
      tuple = JSON.parse message.utf8Data
      return if not tuple?.length == 2
      [cmd, data] = tuple
      return if cmd != 'state'
      world.loadFromState data
      view.draw world

  client.connect "ws://#{ argv.host }:#{ argv.port }", 'realm-protocol'

tryConnecting()
