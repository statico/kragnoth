#!/usr/bin/env coffee

optimist = require 'optimist'
WebSocketClient = require('websocket').client

{Map} = require '../lib/map'
{ClientWorld} = require '../lib/game'
{Vec2} = require 'justmath'

argv = optimist
  .options('h', alias: 'host', default: '127.0.0.1')
  .options('p', alias: 'port', default: 8200)
  .options('b', alias: 'bgcolor', default: 'black')
  .options('f', alias: 'fgcolor', default: 'white')
  .options('v', alias: 'verbose').boolean('v')
  .argv

debug = (message...) ->
  if argv.verbose then console.error message...

class View

  @Colors: ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white']

  constructor: (@bgcolor, @fgcolor) ->
    @charm = require('charm')()
    @charm.pipe(process.stdout)
    @charm
      .reset()
      .erase('screen')
      .cursor(false)
      .position(0, 0)
    @charm.background(@bgcolor)
    @charm.foreground(@fgcolor)

  drawMapCell: (cell) ->
    p = cell
    @charm.position p.x + 1, p.y + 1
    switch world.map.get(p)
      when Map.Cells.EMPTY
        @charm.write ' '
      when Map.Cells.WALL
        switch world.map.wallType p
          when 'h' then @charm.write '-'
          when 'v' then @charm.write '|'
          else @charm.write '+'
      when Map.Cells.ROOM
        @charm.write '.'
      when Map.Cells.DOOR
        @charm.write '_'
      when Map.Cells.HALLWAY
        @charm.write '#'

  drawAgent: (agent) ->
    @charm.position agent.location.x + 1, agent.location.y + 1

    # All dead agents are a corpse.
    if not agent.isAlive()
      @charm.write 'x'
      return

    switch agent.type
      when 'drone' then @charm.write 'o'
      when 'mosquito'
        @charm.push(true).foreground('red').write('M').pop(true)
      when 'drone' then @charm.write 'o'
      else @charm.write '?'

  draw: (world) ->
    # If we haven't seen the world before, draw the whole thing from
    # scratch and prime the @oldlocations pump (TODO world is a bit of a
    # misnomer; presently each world is actually a realm, ie a floor of
    # the dungeon).  If we HAVE seen the world before, only draw the
    # things that have changed since the last rendering.
    if not @oldlocations?
      # save the locations
      @oldlocations = {}
      for a in world.agents
        @oldlocations[a.id] = new Object a.location
      debug "made a new oldlocations:\n", @oldlocations

      # erase & draw the entire screen (ie the whole map).
      @charm.erase 'screen'
      world.map.foreach (p) =>
        @drawMapCell p

    if argv.verbose
      # v-- this is actually briefer than using [].filter or [].reduce
      skeeter = a for a in world.agents when a.type is 'mosquito'
      skeeter.old_location = @oldlocations[skeeter.id]

      debug '[old, new] =', [skeeter.old_location, skeeter.location]

    # first, erase all the old positions by redrawing the appropriate map tiles
    for k, v of @oldlocations
      if argv.verbose and v.id is skeeter.id
        debug "about to overwrite this position: ", v.location
      @drawMapCell new Vec2 v

    # second, draw all the new positions
    # Always draw alive agents on top of dead ones.
    world.agents.sort (a, b) -> if a.isAlive() then 1 else -1
    @drawAgent a for a in world.agents

    # Remember the world for when the next frame comes around
    for a in world.agents
      @oldlocations[a.id] = new Object a.location

  teardown: ->
    @charm.cursor(true).erase('line')

client = null
world = new ClientWorld()
view = new View argv.bgcolor, argv.fgcolor

process.on 'exit', ->
  view.teardown()

tryConnecting = ->

  client = new WebSocketClient()

  client.on 'connectFailed', (err) ->
    if err.code in ['ECONNREFUSED', 'ECONNRESET']
      setTimeout tryConnecting, 500
    else
      console.error err

  client.on 'connect', (conn) ->
    console.log 'Connected to realm server'

    conn.on 'message', (message) ->
      tuple = JSON.parse message.utf8Data
      return if not tuple?.length == 2
      [cmd, data] = tuple
      return if cmd != 'state'
      world.loadFromState data
      view.draw world

  client.connect "ws://#{ argv.host }:#{ argv.port }", 'realm-protocol'

tryConnecting()
